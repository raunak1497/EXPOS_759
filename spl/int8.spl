//mode flag to fork sys call
[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+9]=8;

//user stack
[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+13]=SP;

//switching to kernel stack
SP=[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+11];


//allocate memory and set process table
R1=GET_PCB_ENTRY;
call MOD_1;

//if free process table is not available
if(R0==-1)then
	[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+9]=0;//mode flag to user
	SP=[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+13];//switch back to user stck
	multipush(R0);
	alias userSP R0;
	userSP=[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+13];
	[[PTBR+2*(userSP-1)/512]*512+((userSP-1)%512)]=-1;//return value -1 to stack
	multipop(R0);
	ireturn; 
endif;

//if free process table is available
alias parentPID R3;
alias childPID R4;
alias parentPTBR R5;
alias childPTBR R6;
alias parentPT R7;
alias childPT R8;

parentPID=[SYSTEM_STATUS_TABLE+1];
childPID=R0;
parentPTBR=PAGE_TABLE_BASE+(20*parentPID);
childPTBR=PAGE_TABLE_BASE+(20*childPID);
parentPT=PROCESS_TABLE+parentPID*16;
childPT=PROCESS_TABLE+childPID*16;

//if heap pages are not allocated allocate heap pages

if([PTBR+4]==-1)then
	backup;
	R1=GET_FREE_PAGE;
	call MOD_2;
	[PTBR+4]=R0;
	[PTBR+5]="0110";
	backup;
endif;

if([PTBR+6]==-1)then
	backup;
	R1=GET_FREE_PAGE;
	call MOD_2;
	[PTBR+6]=R0;
	[PTBR+7]="0110";
	backup;
endif;

//allocate 2 stack and one user area page number

//stack 1
backup;
R1=GET_FREE_PAGE;
call MOD_2;
[childPTBR+16]=R0;
[childPTBR+17]="0110";
restore;

//stack 2
backup;
R1=GET_FREE_PAGE;
call MOD_2;
[childPTBR+18]=R0;
[childPTBR+19]="0110";
restore;

//user area page number
backup;
R1=GET_FREE_PAGE;
call MOD_2;
[parentPT+11]=R0;
restore;

alias i R9;

while(i<16)do
	if((i==3)||(i==4)||(i==6)||(i==7)||(i==8)||(i==9)||(i==13))then
		[childPT+i]=[parentPT+i];
	endif;
	i=i+1;
endwhile;

//setting up process table for 
//parent PID
[childPT+2]=parentPID;

//tick field for child
[childPT]=0;

//mode
[childPT+9]=0;

//kernel stack
[childPT+12]=0;

//copy parent per process resource table
alias parent_userarea_page R10;
alias child_userarea_page R11;
alias temp R12;

//copy parent per process resource table
parent_userarea_page=[PROCESS_TABLE+parentPID*16+11];
child_userarea_page=[PROCESS_TABLE+childPID*16+11];
i=496;
while(i<512)do
	[child_userarea_page+i]=[parent_userarea_page+i];
	[child_userarea_page+i+1]=[parent_userarea_page+i+1];
	i=i+2;
endwhile;

//copy parent per process disk map table
i=0;
while(i<10)do
	[DISK_MAP_TABLE+(childPID*10)+i]=[DISK_MAP_TABLE+(parentPID*10)+i];
	i=i+1;
endwhile;

//copying page table entries
i=0;
while(i<15)do
	temp=[PAGE_TABLE_BASE+(parentPID)*20+i];
	[PAGE_TABLE_BASE+(childPID)*20+i]=temp;
	[PAGE_TABLE_BASE+(childPID)*20+i+1]=[PAGE_TABLE_BASE+(parentPID)*20+i+1];
	if(temp!=-1)then
		[MEMORY_FREE_LIST+temp]=[MEMORY_FREE_LIST+temp]+1;
	endif;
	i=i+2;
endwhile;

//copy contents of parent user stack
alias parent_userstack R13;
alias child_userstack R14;

//stack 1
parent_userstack=[PAGE_TABLE_BASE+parentPID*20+16];
child_userstack=[PAGE_TABLE_BASE+childPID*20+16];

if(parent_userstack!=-1)then
	i=0;
	while(i<512)do
		[child_userstack*512+i]=[parent_userstack*512+i];
		i=i+1;
	endwhile;
endif;

//stack 2
parent_userstack=[PAGE_TABLE_BASE+parentPID*20+18];
child_userstack=[PAGE_TABLE_BASE+childPID*20+18];

if(parent_userstack!=-1)then
	i=0;
	while(i<512)do
		[child_userstack*512+i]=[parent_userstack*512+i];
		i=i+1;
	endwhile;
endif;


//store BP to beginning of kernel stack
[[PROCESS_TABLE+childPID*16+11]*512]=BP;

//return value of child process is 0
child_userstack=[PROCESS_TABLE+(childPID*16)+13];

[[PAGE_TABLE_BASE + (childPID * 20) + (2 * ((child_userstack - 1) / 512))] * 512 + ((child_userstack - 1) % 512)] = 0;


//return child pid to parent process
child_userstack=[PROCESS_TABLE+(childPID*16)+13];

[[PAGE_TABLE_BASE + (childPID * 20) + (2 * ((child_userstack - 1) / 512))] * 512 + ((child_userstack - 1) % 512)] = 0;

//state of child process is created
[PROCESS_TABLE + (childPID*16)+4]=CREATED;

//change mode of parent to user
[PROCESS_TABLE+(parentPID*16)+9]=0;

SP=[PROCESS_TABLE+(parentPID*16)+13];
breakpoint;
ireturn;
